#include <vector>

constexpr int32_t maze_width		= 224;
constexpr int32_t maze_height		= 248;
constexpr int32_t tile_map_width	= maze_width / 8;
constexpr int32_t tile_map_height	= maze_height / 8;
constexpr int32_t display_scale		= 4;
constexpr int32_t display_width		= maze_width * display_scale;
constexpr int32_t display_height	= maze_height * display_scale;

enum tile_flags : uint8_t
{
	tile_flags_wall			= 0x00,
	tile_flags_open_up		= 0x01,
	tile_flags_open_down	= 0x02,
	tile_flags_open_left	= 0x04,
	tile_flags_open_right	= 0x08,
};

static uint8_t tile_map[tile_map_width * tile_map_height] = {
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0xA,0xC,0xC,0xC,0xC,0xE,0xC,0xC,0xC,0xC,0xC,0x6,0x0,0x0,0xA,0xC,0xC,0xC,0xC,0xC,0xE,0xC,0xC,0xC,0xC,0x6,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0xB,0xC,0xC,0xC,0xC,0xF,0xC,0xC,0xE,0xC,0xC,0xD,0xC,0xC,0xD,0xC,0xC,0xE,0xC,0xC,0xF,0xC,0xC,0xC,0xC,0x7,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0x9,0xC,0xC,0xC,0xC,0x7,0x0,0x0,0x9,0xC,0xC,0x6,0x0,0x0,0xA,0xC,0xC,0x5,0x0,0x0,0xB,0xC,0xC,0xC,0xC,0x5,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0xA,0xC,0xC,0xD,0xC,0xC,0xD,0xC,0xC,0x6,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0xB,0xC,0xC,0x6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xB,0xC,0xC,0x6,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0xB,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0x6,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0xA,0xC,0xC,0xC,0xC,0xF,0xC,0xC,0xD,0xC,0xC,0x6,0x0,0x0,0xA,0xC,0xC,0xB,0xC,0xC,0xF,0xC,0xC,0xC,0xC,0x6,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0x9,0xC,0x6,0x0,0x0,0xB,0xC,0xC,0xE,0xC,0xC,0xD,0xC,0xC,0xD,0xC,0xC,0xE,0xC,0xC,0x7,0x0,0x0,0xA,0xC,0x5,0x0,
	0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,
	0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,
	0x0,0xA,0xC,0xD,0xC,0xC,0x5,0x0,0x0,0x9,0xC,0xC,0x6,0x0,0x0,0xA,0xC,0xC,0x5,0x0,0x0,0x9,0xC,0xC,0xD,0xC,0xA,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0x9,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0xD,0xC,0xC,0xD,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0x5,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
};

static uint32_t	pathman_anim_counter;
static uint32_t	ghost_anim_counter;
static int32_t	pathman_tile_x	= 1;
static int32_t	pathman_tile_y	= 1;
static int32_t	ghost_tile_x	= 13;
static int32_t	ghost_tile_y	= 17;

static void draw_sprite(sprite_batch* sb, texture* sprite_sheet, int32_t tile_x, int32_t tile_y, int32_t src_x, int32_t src_y)
{
	const int32_t x = (tile_x * 8) - 3;
	const int32_t y = (tile_y * 8) - 3;

	sprite_batch_draw(sb, sprite_sheet, x * display_scale, y * display_scale, 14 * display_scale, 14 * display_scale, src_x, src_y, 14, 14);
}

static void render(d3d_context* d3d, sprite_batch* sb, texture* sprite_sheet)
{
	sprite_batch_begin(sb);

	sprite_batch_draw(sb, sprite_sheet, 0, 0, 224 * display_scale, 248 * display_scale, 228, 0, 224, 248);

	if (ghost_anim_counter < 8)
		draw_sprite(sb, sprite_sheet, ghost_tile_x, ghost_tile_y, 585, 65);
	else
		draw_sprite(sb, sprite_sheet, ghost_tile_x, ghost_tile_y, 601, 65);

	if (++ghost_anim_counter == 16)
		ghost_anim_counter = 0;

	if (pathman_anim_counter < 8)
		draw_sprite(sb, sprite_sheet, pathman_tile_x, pathman_tile_y, 457, 1);
	else if (pathman_anim_counter < 16)
		draw_sprite(sb, sprite_sheet, pathman_tile_x, pathman_tile_y, 473, 1);
	else
		draw_sprite(sb, sprite_sheet, pathman_tile_x, pathman_tile_y, 489, 1);

	if (++pathman_anim_counter == 24)
		pathman_anim_counter = 0;

	sprite_batch_end(sb);
}

static void load_sprite_sheet(texture* sprite_sheet, d3d_context* d3d)
{
	size_t image_file_size;
	void* image_file_data = read_entire_file("asset/pacman.png", &image_file_size);
	load_png(d3d, sprite_sheet, image_file_data, image_file_size);
	free(image_file_data);
}

struct node
{
	node() {
		posX = -1;
		posY = -1;
		parentX = -1;
		parentY = -1;
		h = 0;
		g = 0;
		f = 0;
	}
	node(int x, int y)
		: node()
	{
		posX = x;
		posY = y;

	}

	bool operator == (node const &obj) {
		if (this->posX == obj.posX && this->posY == obj.posY)
			return true;
		return false;
	}

	int posX, posY, parentX, parentY;
	float h, g, f;
};

node getLowestF(const std::vector<node>& nodes) {
	node returnNode = nodes[0];

	for (int i(1); i < nodes.size(); i++) {
		if (nodes[i].f < returnNode.f)
			returnNode = nodes[i];
	}

	return returnNode;
}

void removeNode(std::vector<node>& nodes, const node& node) {
	for (int i(0); i < nodes.size(); i++) {
		if (nodes[i] == node) {
			auto iterator = std::find(nodes.begin(), nodes.end(), node);
			nodes.erase(iterator);
			return;
		}
	}
}

node makeNode(int x, int y) {
	int Index = (y * tile_map_width) + x;
	if (tile_map[Index] != 0x0)
	{
		node newNode = node(x, y);
		//set parent up here

		return newNode;
	}
	return node();
}

std::vector<node> getAdjacent(node Node) {
	std::vector<node> nodes;
	int index = (Node.posY * tile_map_width) + Node.posX;

	nodes.push_back(makeNode(Node.posX, Node.posY - 1));	// Top
	nodes.push_back(makeNode(Node.posX - 1, Node.posY));	//Left
	nodes.push_back(makeNode(Node.posX + 1, Node.posY));	//Right
	nodes.push_back(makeNode(Node.posX, Node.posY + 1));	//Bottom

	for (int i(0); i < nodes.size(); i++)
	{
		if (nodes[i].posX == -1) {
			removeNode(nodes, nodes[i]);
			i--;
		}
		else {
			nodes[i].parentX = Node.posX;
			nodes[i].parentY = Node.posY;
		}
	}

	return nodes;
}

bool inList(std::vector<node>& nodes, node& node) {
	for (int i(0); i < nodes.size(); i++) {
		if (nodes[i] == node) {
			return true;
		}
	}
	return false;
}

node getNodeInList(std::vector<node>& nodes, node& Node) {
	for (int i(0); i < nodes.size(); i++) {
		if (nodes[i] == Node) {
			return nodes[i];
		}
	}
	return node();
}

float distanceBetweenNodes(const node& node1, const node& node2) {
	return pow((node1.posX - node2.posX), 2) + pow((node1.posY - node2.posY), 2);
}

std::vector<node> pathFinding() {
	std::vector<node> open, closed, finalNodes;

	// Add the start and target node
	node start = node(pathman_tile_x, pathman_tile_y);
	open.push_back(start);
	node target = node(ghost_tile_x, ghost_tile_y);

	// Loop until you find the end
	while (!open.empty()) {
		// Get the current node
		node currentNode = getLowestF(open);
		removeNode(open, currentNode);
		closed.push_back(currentNode);

		if (inList(closed, target)){
			target = getNodeInList(closed, target);
			break;
		}

		// Generate children
		std::vector<node> children = getAdjacent(currentNode);

		for (int i(0); i < children.size(); i++) {
			//Check if already checked
			if (inList(closed, children[i]))
				continue;

			//Create values
			children[i].g = currentNode.g + distanceBetweenNodes(currentNode, children[i]); // Uniform-Cost (Backwards Cost)
			children[i].h = distanceBetweenNodes(children[i], target);						// Greedy (Forward Cost)
			children[i].f = children[i].g + children[i].h;									// A* Combines Uniform-cost and Greedy

			//Check if child is already in open
			if (inList(open, children[i])) {
				node nodeInList = getNodeInList(open, children[i]);
				if (children[i].g > nodeInList.g)
					continue;
			}

			//Add Child to Open
			open.push_back(children[i]);
		}

	}

	bool end = false;
	while (!end) {
		finalNodes.push_back(target);
		
		if (target == start)
			end = true;
		else {
			node parent = node(target.parentX, target.parentY);
			target = getNodeInList(closed, parent);
		}
	}
	
	std::reverse(finalNodes.begin(), finalNodes.end());

	return finalNodes;
}

int main(void)
{
	// Create and open window
	display_context display;
	create_display(&display, "Path-Man", -1, -1, display_width, display_height, false);

	// Initialise D3D
	d3d_context d3d;
	init_d3d(&d3d, &display, true);

	// Initialise sprite batch renderer
	sprite_batch sb;
	sprite_batch_init(&sb, &d3d);

	// Load assets
	texture sprite_sheet;
	load_sprite_sheet(&sprite_sheet, &d3d);

	std::vector<node> finalNodes = pathFinding();
	int count = 0, frame = 0;

	// Main loop
	bool quit = false;
	while (!quit)
	{
		// Handle all queued messages from Windows API
		MSG msg;
		while (PeekMessageW(&msg, nullptr, 0, 0, PM_REMOVE))
		{
			switch (msg.message)
			{
			case WM_QUIT:
				quit = true;
				break;
			default:
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
		}

		begin_frame(&d3d);

		//Move Sprite
		if (frame > 30) {
			pathman_tile_x = finalNodes[count].posX;
			pathman_tile_y = finalNodes[count].posY;
			count++;
			frame = 0;
		}

		// Rendering code goes here
		render(&d3d, &sb, &sprite_sheet);

		frame += 1;
		end_frame(&d3d);
	}

	// Release D3D objects in order to shut down cleanly
	sprite_sheet.buffer->Release();
	sprite_sheet.srv->Release();
	sprite_batch_term(&sb);
	term_d3d(&d3d);

	// Tell windows to terminate the application process and return a successful error code
	ExitProcess(0);
}